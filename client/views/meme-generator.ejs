<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <meta name="description" content="<%= description %>">
    <meta name="keywords" content="$AQUA, AI meme generator, Leonardo AI, crypto memes, SUI network, cryptocurrency memes, meme creator, viral memes, blockchain memes, community memes, social media sharing, meme templates">
    <meta name="author" content="$AQUA Team">
    <link rel="canonical" href="<%= canonicalUrl %>">
    <link rel="icon" type="image/png" href="/aquacat.png">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="<%= title %>">
    <meta property="og:description" content="<%= description %>">
    <meta property="og:image" content="<%= ogImage %>">
    <meta property="og:url" content="<%= canonicalUrl %>">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="$AQUA">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="<%= title %>">
    <meta name="twitter:description" content="<%= description %>">
    <meta name="twitter:image" content="<%= ogImage %>">
    <meta name="twitter:site" content="@AQUA_on_SUI">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="/css/style.css?v=2.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        .meme-generator-container {
            min-height: 100vh;
            padding-top: 100px;
            padding-bottom: 50px;
        }
        
        .generator-hero {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .generator-hero h1 {
            font-family: 'Fredoka One', cursive;
            font-size: 3.5rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--main-blue), var(--anim-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Step Flow Layout */
        .generator-steps {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }
        
        .step-container {
            background: linear-gradient(145deg, var(--accent-dark), #03223f);
            border-radius: 20px;
            border: 1px solid rgba(77, 162, 255, 0.2);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .step-container.active {
            border-color: var(--main-blue);
            box-shadow: 0 10px 30px var(--shadow);
        }
        
        .step-header {
            padding: 25px 30px;
            background: rgba(77, 162, 255, 0.1);
            border-bottom: 1px solid rgba(77, 162, 255, 0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .step-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .step-number {
            background: var(--main-blue);
            color: var(--white);
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        .step-title h3 {
            color: var(--main-blue);
            font-family: 'Fredoka One', cursive;
            font-size: 1.4rem;
            margin: 0;
        }
        
        .step-toggle {
            font-size: 1.2rem;
            color: var(--main-blue);
            transition: transform 0.3s ease;
        }
        
        .step-container.collapsed .step-toggle {
            transform: rotate(180deg);
        }
        
        .step-content {
            padding: 30px;
            display: none;
        }
        
        .step-container.active .step-content {
            display: block;
        }
        
        .step-container.collapsed .step-content {
            display: none;
        }
        
        .step-container.collapsed .step-header {
            background: rgba(77, 162, 255, 0.05);
            border-bottom: 1px solid rgba(77, 162, 255, 0.1);
        }
        
        .step-container.active .step-header {
            background: rgba(77, 162, 255, 0.1);
            border-bottom: 1px solid rgba(77, 162, 255, 0.2);
        }
        
        /* Primary Choice Section */
        .primary-choice {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .choice-card {
            background: rgba(77, 162, 255, 0.05);
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .choice-card:hover {
            background: rgba(77, 162, 255, 0.1);
            border-color: var(--main-blue);
            transform: translateY(-5px);
            box-shadow: 0 10px 25px var(--shadow);
        }
        
        .choice-card.selected {
            background: rgba(77, 162, 255, 0.15);
            border-color: var(--anim-light);
        }
        
        .choice-icon {
            font-size: 3rem;
            color: var(--main-blue);
            margin-bottom: 20px;
        }
        
        .choice-card h4 {
            color: var(--main-blue);
            font-size: 1.3rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--main-blue);
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            background: rgba(77, 162, 255, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
            margin-top: 20px;
            display: none;
        }
        
        .upload-zone.active {
            display: block;
        }
        
        .upload-zone:hover, .upload-zone.dragover {
            background: rgba(77, 162, 255, 0.1);
            border-color: var(--anim-light);
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 3rem;
            color: var(--main-blue);
            margin-bottom: 15px;
        }
        
        /* AI Generation Form */
        .ai-form {
            display: none;
            margin-top: 20px;
        }
        
        .ai-form.active {
            display: block;
        }
        
        .prompt-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 15px;
            background: rgba(77, 162, 255, 0.05);
            color: var(--text-light);
            font-size: 1rem;
            margin-bottom: 20px;
            min-height: 100px;
            resize: vertical;
        }
        
        .prompt-input:focus {
            outline: none;
            border-color: var(--main-blue);
            background: rgba(77, 162, 255, 0.1);
        }
        
        /* Canvas and Editing Layout */
        .editing-layout {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            margin-top: 30px;
        }
        
        .canvas-section {
            background: linear-gradient(145deg, var(--accent-dark), #03223f);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(77, 162, 255, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-container {
            border-radius: 15px;
            overflow: hidden;
            background: transparent;
            margin-bottom: 20px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--accent-dark);
        }
        
        .canvas-container canvas {
            display: block;
            border: none !important;
            outline: none !important;
            border-radius: 13px;
            background: #ffffff;
        }
        
        .canvas-toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .editing-sidebar {
            background: linear-gradient(145deg, var(--accent-dark), #03223f);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(77, 162, 255, 0.2);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        /* User Images Gallery */
        .recent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
            min-height: 200px;
        }
        
        .recent-item {
            aspect-ratio: 1;
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
            background: rgba(77, 162, 255, 0.05);
            position: relative;
        }
        
        .recent-item:hover {
            border-color: var(--main-blue);
            transform: translateY(-2px);
        }
        
        .recent-item:active {
            transform: translateY(0px) scale(0.98);
        }
        
        .recent-item.selected {
            border-color: var(--main-blue);
            box-shadow: 0 0 0 3px rgba(77, 162, 255, 0.5);
            background: rgba(77, 162, 255, 0.1);
        }
        
        .recent-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .recent-item .remove-image {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: none;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .recent-item .remove-image:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        .recent-item:hover .remove-image {
            display: block;
        }
        
        .recent-item {
            cursor: pointer;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .empty-gallery {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
        }
        
        /* Social Sharing Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .modal-overlay.show {
            display: flex;
        }
        
        /* Image Preview Modal Styles */
        .image-preview-modal {
            max-width: 600px;
            width: 100%;
        }
        
        .preview-content {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .preview-image-container {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(77, 162, 255, 0.1);
            border-radius: 15px;
        }
        
        .preview-image-container img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .preview-info {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            font-size: 0.9rem;
            color: var(--anim-light);
        }
        
        .preview-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .preview-actions .btn-small {
            min-width: 140px;
        }
        
        .modal-content {
            background: var(--accent-dark);
            border-radius: 20px;
            padding: 30px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            border: 2px solid var(--main-blue);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin: auto;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-light);
            font-size: 24px;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .modal-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(77, 162, 255, 0.2);
        }
        
        .modal-header h2 {
            color: var(--main-blue);
            margin: 0;
            font-size: 22px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .modal-header i {
            font-size: 20px;
        }
        
        .share-preview {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(77, 162, 255, 0.1);
            border-radius: 15px;
        }
        
        .share-preview img {
            max-width: 150px;
            max-height: 150px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 2px solid rgba(77, 162, 255, 0.3);
        }
        
        .share-message {
            width: 100%;
            min-height: 80px;
            padding: 15px;
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 10px;
            background: rgba(77, 162, 255, 0.05);
            color: var(--text-light);
            resize: vertical;
            font-family: inherit;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .share-message::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .social-platforms {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .social-platform {
            background: linear-gradient(45deg, var(--main-blue), #6db9ff);
            color: var(--white);
            padding: 18px 20px;
            border-radius: 12px;
            text-decoration: none;
            text-align: center;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-weight: 600;
            font-size: 16px;
            border: 2px solid transparent;
            cursor: pointer;
        }
        
        .social-platform:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(77, 162, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .social-platform i {
            font-size: 18px;
        }
        
        .social-platform.twitter { 
            background: linear-gradient(45deg, #1DA1F2, #0d8bd9); 
        }
        .social-platform.twitter:hover {
            box-shadow: 0 8px 25px rgba(29, 161, 242, 0.4);
        }
        
        .social-platform.reddit { 
            background: linear-gradient(45deg, #FF4500, #cc3700); 
        }
        .social-platform.reddit:hover {
            box-shadow: 0 8px 25px rgba(255, 69, 0, 0.4);
        }
        
        .social-platform.facebook { 
            background: linear-gradient(45deg, #1877F2, #0d65d9); 
        }
        .social-platform.facebook:hover {
            box-shadow: 0 8px 25px rgba(24, 119, 242, 0.4);
        }
        
        .social-platform.instagram { 
            background: linear-gradient(45deg, #E4405F, #bc2a8d); 
        }
        .social-platform.instagram:hover {
            box-shadow: 0 8px 25px rgba(228, 64, 95, 0.4);
        }
        
        .social-platform.tiktok { 
            background: linear-gradient(45deg, #000000, #333333); 
        }
        .social-platform.tiktok:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }
        
        /* Mobile responsive styles for modal */
        @media (max-width: 768px) {
            .modal-overlay {
                padding: 10px;
            }
            
            .modal-content {
                padding: 20px;
                max-width: 100%;
                border-radius: 15px;
            }
            
            .modal-close {
                top: 10px;
                right: 15px;
                width: 30px;
                height: 30px;
                font-size: 20px;
            }
            
            .modal-header h2 {
                font-size: 20px;
            }
            
            .modal-header i {
                font-size: 18px;
            }
            
            .share-preview {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .share-preview img {
                max-width: 120px;
                max-height: 120px;
            }
            
            .share-message {
                min-height: 60px;
                padding: 12px;
                font-size: 14px;
            }
            
            .social-platform {
                padding: 15px 18px;
                font-size: 15px;
            }
            
            .social-platform i {
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .modal-content {
                padding: 15px;
            }
            
            .modal-header {
                margin-bottom: 20px;
                padding-bottom: 12px;
            }
            
            .modal-header h2 {
                font-size: 18px;
            }
            
            .modal-header i {
                font-size: 16px;
            }
            
            .share-preview img {
                max-width: 100px;
                max-height: 100px;
            }
            
            .social-platform {
                padding: 12px 15px;
                font-size: 14px;
                gap: 10px;
            }
        }
        
        /* Step Navigation */
        .step-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(77, 162, 255, 0.1);
        }
        
        .btn-secondary-small {
            background: linear-gradient(45deg, #666, #888);
            color: var(--white);
        }
        
        .btn-secondary-small:hover {
            background: linear-gradient(45deg, #555, #777);
        }
        
        /* Control Groups */
        .control-group {
            margin-bottom: 25px;
            border-bottom: 1px solid rgba(77, 162, 255, 0.1);
            padding-bottom: 20px;
        }
        
        .control-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .control-group h4 {
            color: var(--main-blue);
            margin-bottom: 15px;
            font-size: 1.1rem;
            font-family: 'Fredoka One', cursive;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Tool Buttons */
        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .tool-btn {
            background: rgba(77, 162, 255, 0.1);
            color: var(--text-light);
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .tool-btn:hover {
            background: rgba(77, 162, 255, 0.2);
            border-color: var(--main-blue);
        }
        
        .tool-btn.active {
            background: var(--main-blue);
            color: var(--white);
            border-color: var(--anim-light);
        }
        
        /* Shape Tools */
        .shape-tools {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .shape-btn {
            aspect-ratio: 1;
            background: rgba(77, 162, 255, 0.1);
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }
        
        .shape-btn:hover, .shape-btn.active {
            background: var(--main-blue);
            color: var(--white);
        }
        
        /* Form Controls */
        .form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .form-col {
            flex: 1;
        }
        
        .form-input, .form-select {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 10px;
            background: rgba(77, 162, 255, 0.05);
            color: var(--text-light);
            font-size: 0.9rem;
        }
        
        .form-select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%234DA2FF' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 10px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 35px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        
        .form-select option {
            background: var(--accent-dark);
            color: var(--text-light);
            padding: 10px;
            border: none;
        }
        
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--main-blue);
            background: rgba(77, 162, 255, 0.1);
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            color: var(--anim-light);
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .range-input {
            width: 100%;
            margin: 10px 0;
        }
        
        .range-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: var(--anim-light);
        }
        
        .color-picker-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .color-input {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 8px;
            background: transparent;
            cursor: pointer;
        }
        
        /* Action Buttons */
        .btn-small {
            background: linear-gradient(45deg, var(--main-blue), #6db9ff);
            color: var(--white);
            padding: 10px 20px;
            border-radius: 20px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }
        
        .btn-small:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow);
        }
        
        .btn-small:disabled {
            cursor: not-allowed;
            opacity: 0.5 !important;
            transform: none !important;
        }
        
        .btn-secondary-small {
            background: transparent;
            color: var(--main-blue);
            border: 2px solid var(--main-blue);
        }
        
        .btn-secondary-small:hover:not(:disabled) {
            background: var(--main-blue);
            color: var(--white);
        }
        
        .btn-full {
            width: 100%;
            margin-bottom: 10px;
        }
        
        /* Responsive Design */
        /* Model Selection */
        .model-selection {
            margin-bottom: 20px;
        }
        
        .model-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 10px;
        }
        
        .model-card {
            background: rgba(77, 162, 255, 0.05);
            border: 2px solid rgba(77, 162, 255, 0.3);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }
        
        .model-card:hover {
            background: rgba(77, 162, 255, 0.1);
            border-color: var(--main-blue);
            transform: translateY(-2px);
        }
        
        .model-card.selected {
            background: rgba(77, 162, 255, 0.15);
            border-color: var(--anim-light);
            box-shadow: 0 0 20px rgba(77, 162, 255, 0.3);
        }
        
        .model-card.recommended {
            border-color: var(--main-blue);
            background: rgba(77, 162, 255, 0.1);
        }
        
        .model-card.recommended::before {
            content: "‚≠ê RECOMMENDED";
            position: absolute;
            top: -8px;
            left: 10px;
            background: var(--main-blue);
            color: var(--white);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }
        
        .model-card.recommended {
            position: relative;
        }
        
        .model-name {
            font-weight: 700;
            color: var(--main-blue);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .model-description {
            font-size: 0.8rem;
            color: var(--anim-light);
            margin-bottom: 8px;
            line-height: 1.3;
        }
        
        .model-example {
            font-size: 0.75rem;
            color: rgba(192, 230, 255, 0.8);
            font-style: italic;
            line-height: 1.2;
        }
        
        .model-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 0.7rem;
        }
        
        .model-speed {
            color: var(--main-blue);
            font-weight: 600;
        }
        
        .model-speed-badge {
            background: rgba(77, 162, 255, 0.2);
            color: var(--main-blue);
            padding: 2px 8px;
            border-radius: 8px;
            font-weight: 600;
        }

        @media (max-width: 1200px) {
            .editing-layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .editing-sidebar {
                order: 1;
                max-height: none;
            }
        }
        
        @media (max-width: 768px) {
            .generator-hero h1 {
                font-size: 2.5rem;
            }
            
            .primary-choice {
                grid-template-columns: 1fr;
            }
            
            .canvas-section, .editing-sidebar {
                padding: 20px;
            }
            
            .tool-buttons {
                grid-template-columns: 1fr;
            }
            
            .recent-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .model-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Custom Alert/Confirm Modal Styles */
        .custom-alert-modal {
            max-width: 450px;
            width: 100%;
        }
        
        .alert-content {
            text-align: center;
            padding: 20px 0;
        }
        
        .alert-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
        }
        
        .alert-icon.info {
            color: var(--main-blue);
        }
        
        .alert-icon.success {
            color: #4CAF50;
        }
        
        .alert-icon.error {
            color: #f44336;
        }
        
        .alert-icon.warning {
            color: #ff9800;
        }
        
        .alert-message {
            font-size: 1.1rem;
            line-height: 1.6;
            color: var(--text-light);
            margin-bottom: 25px;
            white-space: pre-line;
        }
        
        .alert-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .alert-actions .btn {
            min-width: 100px;
            padding: 12px 24px;
        }
        
        .btn-confirm {
            background: var(--main-blue);
            border: 2px solid var(--main-blue);
        }
        
        .btn-confirm:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }
        
        .btn-cancel {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: var(--text-light);
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="/" class="nav-logo">$AQUA</a>
                <ul class="nav-links">
                    <li><a href="/">Home</a></li>
                    <li><a href="/meme-generator" class="active">Meme Generator</a></li>
                    <li><a href="/gallery">Gallery</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="meme-generator-container">
        <div class="container">
            <div class="generator-hero scroll-animate">
                <h1>üé® $AQUA Meme Generator</h1>
                <p>Create viral memes with AI generation, professional editing tools, and instant sharing!</p>
            </div>

            <div class="generator-steps">
                <!-- Step 1: Choose Your Starting Point -->
                <div class="step-container active scroll-animate" id="step1">
                    <div class="step-header" onclick="toggleStep('step1')">
                        <div class="step-title">
                            <span class="step-number">1</span>
                            <h3>Choose Your Starting Point</h3>
                        </div>
                        <i class="fas fa-chevron-up step-toggle"></i>
                    </div>
                    <div class="step-content">
                        <div class="primary-choice">
                            <div class="choice-card" id="aiChoice">
                                <div class="choice-icon">
                                    <i class="fas fa-magic"></i>
                                </div>
                                <h4>AI Generated Image</h4>
                                <p>Create unique $AQUA themed images with AI assistance</p>
                            </div>
                            <div class="choice-card" id="uploadChoice">
                                <div class="choice-icon">
                                    <i class="fas fa-upload"></i>
                                </div>
                                <h4>Upload Your Own</h4>
                                <p>Upload your own image to create a meme</p>
                            </div>
                        </div>

                        <!-- AI Generation Form -->
                        <div class="ai-form" id="aiForm">
                            <div class="model-selection">
                                <label class="form-label">Choose AI Style:</label>
                                <div class="model-grid" id="modelGrid">
                                    <!-- Models will be loaded here -->
                                </div>
                            </div>
                            <label class="form-label">Describe your $AQUA meme image:</label>
                            <textarea class="prompt-input" id="aiPrompt" placeholder="Example: A wet cat sitting in the rain with a sad expression, holding a SUI blockchain logo, digital art style, meme format"></textarea>
                            <button class="btn-small btn-full" id="generateBtn">
                                <i class="fas fa-magic"></i> Generate with AI
                            </button>
                            <div id="generationStatus" style="display: none; text-align: center; margin-top: 15px;">
                                <i class="fas fa-spinner fa-spin"></i> Generating your image...
                            </div>
                        </div>

                        <!-- Upload Zone -->
                        <div class="upload-zone" id="uploadZone">
                            <div class="upload-icon">
                                <i class="fas fa-cloud-upload-alt"></i>
                            </div>
                            <p>Drop an image here or click to upload</p>
                            <small>Supports JPG, PNG, GIF (max 10MB)</small>
                            <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                        </div>
                    </div>
                </div>

                <!-- Step 2: Your Images -->
                <div class="step-container scroll-animate" id="step2">
                    <div class="step-header" onclick="toggleStep('step2')">
                        <div class="step-title" style="display: flex; align-items: center; width: 100%;">
                            <span class="step-number">2</span>
                            <h3><i class="fas fa-images"></i> Your Images</h3>
                            <div class="storage-info" style="margin-left: auto; font-size: 0.8rem; color: #888;">
                                <span id="storageUsage">Storage: 0 KB</span>
                                <button class="btn-small btn-secondary-small" id="clearStorageBtn" style="margin-left: 10px; padding: 4px 8px; font-size: 0.7rem;">
                                    <i class="fas fa-trash"></i> Clear All
                                </button>
                            </div>
                        </div>
                        <i class="fas fa-chevron-up step-toggle"></i>
                    </div>
                    <div class="step-content">
                        <p>Choose from your uploaded or generated images:</p>
                        <div class="recent-grid" id="userImagesGrid">
                            <div class="empty-gallery">
                                <i class="fas fa-images" style="font-size: 3rem; color: rgba(77, 162, 255, 0.3);"></i>
                                <p style="color: rgba(255,255,255,0.6); margin-top: 10px;">No images yet. Upload or generate some images first!</p>
                            </div>
                        </div>
                        <div class="step-navigation" style="margin-top: 20px; text-align: center;">
                            <button class="btn-small btn-secondary-small" onclick="memeGenerator.expandStep('step1')">
                                <i class="fas fa-arrow-left"></i> Back to Upload/Generate
                            </button>
                            <button class="btn-small" id="proceedToEdit" onclick="memeGenerator.proceedToEdit()" disabled>
                                <i class="fas fa-edit"></i> Edit Selected
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Edit Your Meme -->
                <div class="step-container scroll-animate" id="step3">
                    <div class="step-header" onclick="toggleStep('step3')">
                        <div class="step-title">
                            <span class="step-number">3</span>
                            <h3>Edit Your Meme</h3>
                        </div>
                        <i class="fas fa-chevron-up step-toggle"></i>
                    </div>
                    <div class="step-content">
                        <div class="editing-layout">
                            <!-- Editing Sidebar (Left Side) -->
                            <div class="editing-sidebar">
                                <!-- Add Elements -->
                                <div class="control-group">
                                    <h4><i class="fas fa-plus"></i> Add Elements</h4>
                                    <div class="tool-buttons">
                                        <button class="tool-btn" id="addTextBtn">
                                            <i class="fas fa-font"></i> Text
                                        </button>
                                        <button class="tool-btn" id="addShapeBtn">
                                            <i class="fas fa-shapes"></i> Shapes
                                        </button>
                                    </div>
                                    
                                    <!-- Shape Selection -->
                                    <div class="shape-tools" id="shapeTools" style="display: none;">
                                        <button class="shape-btn" data-shape="rectangle">
                                            <i class="fas fa-square"></i>
                                        </button>
                                        <button class="shape-btn" data-shape="circle">
                                            <i class="fas fa-circle"></i>
                                        </button>
                                        <button class="shape-btn" data-shape="triangle">
                                            <i class="fas fa-play"></i>
                                        </button>
                                        <button class="shape-btn" data-shape="star">
                                            <i class="fas fa-star"></i>
                                        </button>
                                    </div>
                                </div>

                                <!-- Text Controls -->
                                <div class="control-group">
                                    <h4><i class="fas fa-font"></i> Text Styling</h4>
                                    <div class="form-row">
                                        <div class="form-col">
                                            <label class="form-label">Text Content</label>
                                            <input type="text" id="textInput" class="form-input" placeholder="Enter text...">
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-col">
                                            <label class="form-label">Font Family</label>
                                            <select id="fontFamily" class="form-select">
                                                <option value="Impact">Impact</option>
                                                <option value="Arial">Arial</option>
                                                <option value="Fredoka One">Fredoka One</option>
                                                <option value="Poppins">Poppins</option>
                                                <option value="Comic Sans MS">Comic Sans</option>
                                            </select>
                                        </div>
                                        <div class="form-col">
                                            <label class="form-label">Font Size</label>
                                            <input type="range" id="fontSize" class="range-input" min="16" max="120" value="40">
                                            <span id="fontSizeValue">40px</span>
                                        </div>
                                    </div>
                                    <div class="color-picker-group">
                                        <div>
                                            <label class="form-label">Text Color</label>
                                            <input type="color" id="textColor" class="color-input" value="#ffffff">
                                        </div>
                                        <div>
                                            <label class="form-label">Stroke Color</label>
                                            <input type="color" id="strokeColor" class="color-input" value="#000000">
                                        </div>
                                        <div>
                                            <label class="form-label">Stroke Width</label>
                                            <input type="range" id="strokeWidth" class="range-input" min="0" max="10" value="2">
                                            <span id="strokeWidthValue">2px</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Element Properties -->
                                <div class="control-group">
                                    <h4><i class="fas fa-cog"></i> Element Properties</h4>
                                    <div class="range-label">
                                        <span>Opacity</span>
                                        <span id="opacityValue">100%</span>
                                    </div>
                                    <input type="range" id="opacity" class="range-input" min="0" max="100" value="100">
                                    
                                    <div class="form-row" style="margin-top: 15px;">
                                        <div class="form-col">
                                            <label class="form-label">Fill Color</label>
                                            <input type="color" id="fillColor" class="color-input" value="#4DA2FF">
                                        </div>
                                        <div class="form-col">
                                            <label class="form-label">Border Color</label>
                                            <input type="color" id="borderColor" class="color-input" value="#ffffff">
                                        </div>
                                    </div>
                                    <div class="range-label">
                                        <span>Border Width</span>
                                        <span id="borderWidthValue">0px</span>
                                    </div>
                                    <input type="range" id="borderWidth" class="range-input" min="0" max="20" value="0">
                                </div>

                                <!-- Layer Management -->
                                <div class="control-group">
                                    <h4><i class="fas fa-layer-group"></i> Layers</h4>
                                    <div class="tool-buttons">
                                        <button class="tool-btn" id="bringForwardBtn">
                                            <i class="fas fa-level-up-alt"></i> Forward
                                        </button>
                                        <button class="tool-btn" id="sendBackwardBtn">
                                            <i class="fas fa-level-down-alt"></i> Backward
                                        </button>
                                    </div>
                                    <div class="form-row">
                                        <button class="btn-small btn-secondary-small" id="copyBtn" style="flex: 1;" disabled title="Copy selected element (Ctrl+C)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                        <button class="btn-small btn-secondary-small" id="pasteBtn" style="flex: 1;" disabled title="Paste element (Ctrl+V)">
                                            <i class="fas fa-paste"></i> Paste
                                        </button>
                                    </div>
                                    <button class="btn-small btn-secondary-small btn-full" id="deleteBtn" title="Delete selected element (Delete key)">
                                        <i class="fas fa-trash"></i> Delete Selected
                                    </button>
                                </div>

                                <!-- Actions -->
                                <div class="control-group">
                                    <h4><i class="fas fa-share"></i> Save & Share</h4>
                                    <button class="btn-small btn-full" id="saveBtn">
                                        <i class="fas fa-save"></i> Save Meme to Gallery
                                    </button>
                                    <button class="btn-small btn-full btn-share" id="shareToSocialBtn">
                                        <i class="fas fa-share-alt"></i> Share to Social
                                    </button>
                                    <button class="btn-small btn-full btn-secondary-small" id="directShareBtn" style="margin-top: 10px;">
                                        <i class="fas fa-share"></i> Quick Share (No Save)
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Canvas Section (Right Side) -->
                            <div class="canvas-section">
                                <div class="canvas-toolbar">
                                    <button class="btn-small btn-secondary-small" id="undoBtn">
                                        <i class="fas fa-undo"></i> Undo
                                    </button>
                                    <button class="btn-small btn-secondary-small" id="redoBtn">
                                        <i class="fas fa-redo"></i> Redo
                                    </button>
                                    <button class="btn-small btn-secondary-small" id="clearBtn">
                                        <i class="fas fa-trash"></i> Clear
                                    </button>
                                    <button class="btn-small" id="exportBtn">
                                        <i class="fas fa-download"></i> Export
                                    </button>
                                </div>
                                <div class="canvas-container">
                                    <canvas id="memeCanvas" width="600" height="600"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Social Sharing Modal -->
    <div class="modal-overlay" id="shareModal">
        <div class="modal-content">
            <button class="modal-close" data-action="close-modal">&times;</button>
            <div class="modal-header">
                <h2><i class="fas fa-share-alt"></i> Share Your Meme</h2>
            </div>
            
            <div class="share-preview">
                <img id="sharePreviewImage" src="" alt="Meme preview">
                <h4 style="color: var(--text-light); margin: 10px 0;">Add a message (optional):</h4>
                <textarea class="share-message" id="shareMessage" placeholder="Check out this awesome meme I made! üî• #AQUA #MemeGenerator"></textarea>
            </div>
            
            <div class="social-platforms">
                <a href="#" class="social-platform universal" data-platform="universal" style="background: linear-gradient(45deg, #4CAF50, #45a049);">
                    <i class="fas fa-share"></i> Share
                </a>
            </div>
        </div>
    </div>

    <footer>
        <div class="container">
            <div class="social-links">
                <a href="https://x.com/AQUA_on_SUI" target="_blank" aria-label="Twitter"><i class="fab fa-twitter"></i></a>
                <a href="https://t.me/AQUA_CAT_ON_SUI" target="_blank" aria-label="Telegram"><i class="fab fa-telegram"></i></a>
                <a href="https://dexscreener.com/" target="_blank" aria-label="Dexscreener"><i class="fas fa-chart-line"></i></a>
                <a href="https://www.reddit.com/r/AQUA_on_SUI/" target="_blank" aria-label="Reddit"><i class="fab fa-reddit"></i></a>
            </div>
            <p class="disclaimer">
                <strong>Disclaimer:</strong> $AQUA is a meme coin with no intrinsic value or expectation of financial return. It is for entertainment purposes only. Always do your own research.
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/js/script.js?v=2.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <script>
        // Advanced Meme Generator with Full Editing Package
        class AdvancedMemeGenerator {
            constructor() {
                this.canvas = new fabric.Canvas('memeCanvas', {
                    backgroundColor: '#ffffff',
                    preserveObjectStacking: true
                });
                
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 20;
                this.isLoadingFromHistory = false; // Flag to prevent infinite loops during undo/redo
                this.currentMode = null; // 'text', 'shape', null
                this.activeObject = null;
                this.selectedModel = 'creative';
                this.availableModels = {};
                this.selectedUserImage = null;
                this.userImages = this.loadUserImages();
                this.clipboard = null; // For copy/paste functionality
                this.pasteCount = 0; // Track multiple pastes for better positioning
                
                this.initializeEventListeners();
                this.loadAIModels();
                this.refreshUserImagesDisplay();
                this.updateStorageInfo();
                this.setupScrollAnimations();
                this.initializeStepStates();
                
                // Save initial canvas state after everything is initialized
                setTimeout(() => {
                    this.saveCanvasState();
                    this.updateCopyPasteButtons(); // Initialize button states
                }, 100);
            }
            
            initializeEventListeners() {
                // Step toggles
                window.toggleStep = this.toggleStep.bind(this);
                
                // Primary choice selection
                document.getElementById('aiChoice').addEventListener('click', () => {
                    this.selectChoice('ai');
                });
                
                document.getElementById('uploadChoice').addEventListener('click', () => {
                    this.selectChoice('upload');
                });
                
                // File upload
                const uploadZone = document.getElementById('uploadZone');
                const imageUpload = document.getElementById('imageUpload');
                
                uploadZone.addEventListener('click', () => imageUpload.click());
                uploadZone.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadZone.addEventListener('drop', this.handleDrop.bind(this));
                imageUpload.addEventListener('change', this.handleImageUpload.bind(this));
                
                // AI Generation
                document.getElementById('generateBtn').addEventListener('click', this.generateAIImage.bind(this));
                
                // Canvas tools
                document.getElementById('undoBtn').addEventListener('click', this.undo.bind(this));
                document.getElementById('redoBtn').addEventListener('click', this.redo.bind(this));
                document.getElementById('clearBtn').addEventListener('click', this.clearCanvas.bind(this));
                document.getElementById('exportBtn').addEventListener('click', this.exportMeme.bind(this));
                document.getElementById('saveBtn').addEventListener('click', this.saveMeme.bind(this));
                
                // Element tools
                document.getElementById('addTextBtn').addEventListener('click', () => {
                    this.setMode('text');
                });
                
                document.getElementById('addShapeBtn').addEventListener('click', () => {
                    this.setMode('shape');
                    document.getElementById('shapeTools').style.display = 'grid';
                });
                
                // Shape tools
                document.querySelectorAll('.shape-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const shape = e.currentTarget.dataset.shape;
                        this.addShape(shape);
                    });
                });
                
                // Text controls
                document.getElementById('textInput').addEventListener('input', this.updateText.bind(this));
                document.getElementById('fontFamily').addEventListener('change', this.updateTextStyle.bind(this));
                document.getElementById('fontSize').addEventListener('input', this.updateFontSize.bind(this));
                document.getElementById('textColor').addEventListener('change', this.updateTextStyle.bind(this));
                document.getElementById('strokeColor').addEventListener('change', this.updateTextStyle.bind(this));
                document.getElementById('strokeWidth').addEventListener('input', this.updateStrokeWidth.bind(this));
                
                // Element properties
                document.getElementById('opacity').addEventListener('input', this.updateOpacity.bind(this));
                document.getElementById('fillColor').addEventListener('change', this.updateFillColor.bind(this));
                document.getElementById('borderColor').addEventListener('change', this.updateBorderColor.bind(this));
                document.getElementById('borderWidth').addEventListener('input', this.updateBorderWidth.bind(this));
                
                // Layer controls
                document.getElementById('bringForwardBtn').addEventListener('click', this.bringForward.bind(this));
                document.getElementById('sendBackwardBtn').addEventListener('click', this.sendBackward.bind(this));
                document.getElementById('deleteBtn').addEventListener('click', this.deleteSelected.bind(this));
                
                // Copy/Paste controls
                document.getElementById('copyBtn').addEventListener('click', this.copySelected.bind(this));
                document.getElementById('pasteBtn').addEventListener('click', this.pasteElement.bind(this));
                
                // Keyboard shortcuts
                document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));
                
                // Share to social button
                document.getElementById('shareToSocialBtn').addEventListener('click', this.saveAndShare.bind(this));
                
                // Direct share button (for testing)
                document.getElementById('directShareBtn').addEventListener('click', this.openShareModal.bind(this));
                
                // Clear storage button
                document.getElementById('clearStorageBtn').addEventListener('click', this.clearAllImages.bind(this));
                
                // Canvas events
                this.canvas.on('object:modified', () => this.saveCanvasState());
                this.canvas.on('object:added', () => this.saveCanvasState());
                this.canvas.on('object:removed', () => this.saveCanvasState());
                this.canvas.on('selection:created', (e) => {
                    if (e && (e.target || e.selected)) {
                        this.onObjectSelected(e);
                    }
                });
                this.canvas.on('selection:updated', (e) => {
                    if (e && (e.target || e.selected)) {
                        this.onObjectSelected(e);
                    }
                });
                this.canvas.on('selection:cleared', () => this.onSelectionCleared());
            }
            
            toggleStep(stepId) {
                const step = document.getElementById(stepId);
                const isActive = step.classList.contains('active');
                
                if (isActive) {
                    // Collapse this step
                    step.classList.remove('active');
                    step.classList.add('collapsed');
                } else {
                    // Expand this step
                    step.classList.add('active');
                    step.classList.remove('collapsed');
                    step.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            
            selectChoice(choice) {
                // Remove selection from both cards
                document.querySelectorAll('.choice-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // Hide both forms
                document.getElementById('aiForm').classList.remove('active');
                document.getElementById('uploadZone').classList.remove('active');
                
                if (choice === 'ai') {
                    document.getElementById('aiChoice').classList.add('selected');
                    document.getElementById('aiForm').classList.add('active');
                } else {
                    document.getElementById('uploadChoice').classList.add('selected');
                    document.getElementById('uploadZone').classList.add('active');
                }
            }
            
            async loadAIModels() {
                try {
                    const response = await fetch('/api/ai/models');
                    const result = await response.json();
                    
                    if (result.success) {
                        this.availableModels = result.models;
                        this.renderModelSelection();
                    }
                } catch (error) {
                    console.error('Failed to load AI models:', error);
                    // Show fallback models
                    this.availableModels = {
                        creative: {
                            name: "Creative Engine",
                            description: "Best for cartoon-style memes with vibrant colors",
                            example: "A wet cartoon cat with big eyes sitting in the rain",
                            speed: "Fast",
                            recommended: true
                        }
                    };
                    this.renderModelSelection();
                }
            }
            
            renderModelSelection() {
                const grid = document.getElementById('modelGrid');
                grid.innerHTML = '';
                
                Object.entries(this.availableModels).forEach(([key, model]) => {
                    const modelCard = document.createElement('div');
                    modelCard.className = `model-card ${key === 'creative' ? 'selected' : ''} ${model.recommended ? 'recommended' : ''}`;
                    modelCard.dataset.model = key;
                    
                    modelCard.innerHTML = `
                        <div class="model-name">${model.name}</div>
                        <div class="model-description">${model.description}</div>
                        <div class="model-example">"${model.example}"</div>
                        <div class="model-meta">
                            <span class="model-speed-badge">‚ö° ${model.speed}</span>
                        </div>
                    `;
                    
                    modelCard.addEventListener('click', () => {
                        document.querySelectorAll('.model-card').forEach(card => {
                            card.classList.remove('selected');
                        });
                        modelCard.classList.add('selected');
                        this.selectedModel = key;
                    });
                    
                    grid.appendChild(modelCard);
                });
            }

            async generateAIImage() {
                const prompt = document.getElementById('aiPrompt').value;
                if (!prompt.trim()) {
                    await this.showCustomAlert('Please enter a description for your image.', 'warning', 'Missing Description');
                    return;
                }
                
                document.getElementById('generationStatus').style.display = 'block';
                document.getElementById('generateBtn').disabled = true;
                
                try {
                    const response = await fetch('/api/ai/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            model: this.selectedModel
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (response.status === 429) {
                        // Rate limit exceeded
                        const resetTime = new Date(result.resetTime).toLocaleTimeString();
                        await this.showCustomAlert(`Generation limit reached! You can generate 4 images per hour. Try again after ${resetTime}.`, 'warning', 'Rate Limit Reached');
                        document.getElementById('generationStatus').style.display = 'none';
                        return;
                    }
                    
                    if (result.success) {
                        // Show success message with model used
                        const statusDiv = document.getElementById('generationStatus');
                        const demoText = result.demoMode ? ' (Demo Mode)' : '';
                        statusDiv.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Generated with ${result.model.name}${demoText}! Processing...`;
                        
                        // Start polling for generation completion
                        this.pollGenerationStatus(result.generationId, statusDiv);
                        
                        // Update generation counter if provided
                        if (result.rateLimit) {
                            this.updateRateLimitDisplay(result.rateLimit);
                        }
                    } else {
                        await this.showCustomAlert('AI generation failed: ' + (result.error || 'Unknown error'), 'error', 'Generation Failed');
                        document.getElementById('generationStatus').style.display = 'none';
                    }
                } catch (error) {
                    console.error('AI generation error:', error);
                    await this.showCustomAlert('Failed to generate image. Please try again.', 'error', 'Generation Failed');
                    document.getElementById('generationStatus').style.display = 'none';
                } finally {
                    document.getElementById('generateBtn').disabled = false;
                }
            }
            
            async pollGenerationStatus(generationId, statusDiv) {
                let attempts = 0;
                const maxAttempts = 30; // 5 minutes maximum
                
                const checkStatus = async () => {
                    try {
                        const response = await fetch(`/api/ai/status/${generationId}`);
                        const result = await response.json();
                        
                        if (result.success) {
                            if (result.status === 'COMPLETE' && result.images && result.images.length > 0) {
                                // Generation completed successfully
                                const imageUrl = result.images[0].url;
                                statusDiv.innerHTML = `<i class="fas fa-check" style="color: #10B981;"></i> Image generated successfully!`;
                                
                                // Add the generated image to user images
                                await this.addUserImage(imageUrl, 'generated');
                                
                                // Show step 2 (Your Images) and highlight the new image
                                this.expandStep('step2');
                                
                                // Hide status after a moment
                                setTimeout(() => {
                                    statusDiv.style.display = 'none';
                                }, 2000);
                                
                                return; // Stop polling
                            } else if (result.status === 'FAILED') {
                                statusDiv.innerHTML = `<i class="fas fa-times" style="color: #EF4444;"></i> Generation failed. Please try again.`;
                                setTimeout(() => {
                                    statusDiv.style.display = 'none';
                                }, 3000);
                                return; // Stop polling
                            }
                            // If status is PENDING, continue polling
                        }
                        
                        attempts++;
                        if (attempts >= maxAttempts) {
                            statusDiv.innerHTML = `<i class="fas fa-clock" style="color: #F59E0B;"></i> Generation is taking longer than expected. Check back later.`;
                            setTimeout(() => {
                                statusDiv.style.display = 'none';
                            }, 5000);
                            return; // Stop polling
                        }
                        
                        // Continue polling every 10 seconds
                        setTimeout(checkStatus, 10000);
                        
                    } catch (error) {
                        console.error('Error checking generation status:', error);
                        attempts++;
                        if (attempts < maxAttempts) {
                            setTimeout(checkStatus, 10000);
                        } else {
                            statusDiv.innerHTML = `<i class="fas fa-times" style="color: #EF4444;"></i> Unable to check generation status.`;
                            setTimeout(() => {
                                statusDiv.style.display = 'none';
                            }, 3000);
                        }
                    }
                };
                
                // Start polling after a short delay
                setTimeout(checkStatus, 5000);
            }
            
            updateRateLimitDisplay(rateLimit) {
                // Create or update rate limit indicator
                let indicator = document.getElementById('rateLimitIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'rateLimitIndicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 120px;
                        right: 20px;
                        background: rgba(1, 24, 41, 0.95);
                        backdrop-filter: blur(10px);
                        border: 1px solid rgba(77, 162, 255, 0.3);
                        border-radius: 10px;
                        padding: 10px 15px;
                        font-size: 0.9rem;
                        color: var(--text-light);
                        z-index: 1000;
                    `;
                    document.body.appendChild(indicator);
                }
                
                const resetTime = new Date(rateLimit.resetTime).toLocaleTimeString();
                indicator.innerHTML = `
                    <div style="color: var(--main-blue); font-weight: 600; margin-bottom: 3px;">
                        <i class="fas fa-clock"></i> Generation Limit
                    </div>
                    <div>Used: ${rateLimit.used}/4 this hour</div>
                    <div>Resets: ${resetTime}</div>
                `;
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 10000);
            }
            
            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadZone').classList.add('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadZone').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processImageFile(files[0]);
                }
            }
            
            handleImageUpload(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processImageFile(file);
                }
            }
            
            processImageFile(file) {
                if (file.size > 10 * 1024 * 1024) {
                    this.showCustomAlert('File too large! Please use an image under 10MB.', 'warning', 'File Size Limit');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const imageData = e.target.result;
                    await this.addUserImage(imageData, 'upload');
                    
                    // Show step 2 (Your Images) so user can select the uploaded image
                    this.expandStep('step2');
                };
                reader.readAsDataURL(file);
            }
            
            loadImageToCanvas(imageUrl) {
                console.log('Loading image to canvas...');
                
                // Ensure canvas is initialized
                if (!this.canvas) {
                    console.error('Canvas not initialized. Cannot load image.');
                    return;
                }
                
                // Validate image URL
                if (!imageUrl || typeof imageUrl !== 'string') {
                    console.error('Invalid image URL provided:', imageUrl);
                    return;
                }
                
                // Set canvas background
                this.canvas.backgroundColor = '#ffffff';
                
                // Convert data URL to blob to avoid CORS issues
                const convertDataUrlToBlob = (dataUrl) => {
                    const arr = dataUrl.split(',');
                    const mime = arr[0].match(/:(.*?);/)[1];
                    const bstr = atob(arr[1]);
                    let n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    while (n--) {
                        u8arr[n] = bstr.charCodeAt(n);
                    }
                    return new Blob([u8arr], { type: mime });
                };
                
                try {
                    // Create blob URL to avoid cross-origin issues
                    let processedImageUrl = imageUrl;
                    if (imageUrl.startsWith('data:')) {
                        const blob = convertDataUrlToBlob(imageUrl);
                        processedImageUrl = URL.createObjectURL(blob);
                    }
                    
                    // Create image element
                    const testImg = new Image();
                    testImg.crossOrigin = 'anonymous';
                    
                    testImg.onload = () => {
                        try {
                            // Create Fabric image from the loaded HTML image element
                            const fabricImg = new fabric.Image(testImg);
                            
                            if (!fabricImg) {
                                console.error('Failed to create fabric image object');
                                return;
                            }
                            
                            // Scale image to fit canvas
                            const canvasWidth = this.canvas.width || 600;
                            const canvasHeight = this.canvas.height || 600;
                            
                            // Calculate scale to fit within canvas
                            const scaleX = canvasWidth / fabricImg.width;
                            const scaleY = canvasHeight / fabricImg.height;
                            const scale = Math.min(scaleX, scaleY, 1); // Don't upscale
                            
                            fabricImg.scale(scale);
                            
                            // Clear canvas and add the image
                            this.canvas.clear();
                            
                            // Set image properties
                            fabricImg.set({ 
                                selectable: true,
                                hasControls: true,
                                hasBorders: true,
                                left: 0,
                                top: 0
                            });
                            
                            // Add image to canvas
                            this.canvas.add(fabricImg);
                            
                            // Center the image
                            this.canvas.centerObject(fabricImg);
                            
                            // Set the image as active object
                            this.canvas.setActiveObject(fabricImg);
                            
                            // Ensure canvas visibility and fix layering issues
                            const canvasElement = document.getElementById('memeCanvas');
                            if (canvasElement) {
                                canvasElement.style.display = 'block';
                                canvasElement.style.visibility = 'visible';
                                canvasElement.style.opacity = '1';
                                canvasElement.style.position = 'relative';
                                
                                // Fix Fabric.js canvas layering issue
                                const upperCanvas = canvasElement.parentElement.querySelector('.upper-canvas');
                                const lowerCanvas = canvasElement.parentElement.querySelector('.lower-canvas');
                                
                                if (upperCanvas && lowerCanvas) {
                                    console.log('Fixing canvas layering...');
                                    
                                    // Ensure lower canvas (where image renders) is visible
                                    lowerCanvas.style.display = 'block';
                                    lowerCanvas.style.visibility = 'visible';
                                    lowerCanvas.style.opacity = '1';
                                    lowerCanvas.style.zIndex = '1';
                                    
                                    // Ensure upper canvas (interactions) doesn't block the view
                                    upperCanvas.style.backgroundColor = 'transparent';
                                    upperCanvas.style.opacity = '1';
                                    upperCanvas.style.pointerEvents = 'auto';
                                    upperCanvas.style.zIndex = '2';
                                    
                                    console.log('Canvas layering fixed - lower canvas should now be visible');
                                }
                                
                                // Also ensure the parent container is visible
                                const canvasContainer = canvasElement.parentElement;
                                if (canvasContainer) {
                                    canvasContainer.style.display = 'block';
                                    canvasContainer.style.visibility = 'visible';
                                    canvasContainer.style.opacity = '1';
                                }
                                
                                // Scroll canvas into view
                                canvasElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            
                            // Render canvas
                            this.canvas.renderAll();
                            console.log('Canvas rendered with', this.canvas.getObjects().length, 'objects');
                            
                            // Force another render after a short delay
                            setTimeout(() => {
                                this.canvas.renderAll();
                                console.log('Canvas re-rendered');
                                
                                // Check if objects are visible
                                const objects = this.canvas.getObjects();
                                if (objects.length > 0) {
                                    console.log('First object:', {
                                        type: objects[0].type,
                                        visible: objects[0].visible,
                                        opacity: objects[0].opacity,
                                        left: objects[0].left,
                                        top: objects[0].top
                                    });
                                }
                                
                                // Deep canvas debugging
                                const canvasEl = document.getElementById('memeCanvas');
                                if (canvasEl) {
                                    console.log('Canvas element details:', {
                                        width: canvasEl.width,
                                        height: canvasEl.height,
                                        offsetWidth: canvasEl.offsetWidth,
                                        offsetHeight: canvasEl.offsetHeight,
                                        clientWidth: canvasEl.clientWidth,
                                        clientHeight: canvasEl.clientHeight,
                                        style: canvasEl.style.cssText
                                    });
                                    
                                    // Check if there are multiple canvas elements (Fabric.js creates two)
                                    const allCanvases = document.querySelectorAll('#memeCanvas, canvas');
                                    console.log('Total canvas elements found:', allCanvases.length);
                                    allCanvases.forEach((canvas, index) => {
                                        console.log(`Canvas ${index}:`, {
                                            id: canvas.id,
                                            className: canvas.className,
                                            width: canvas.width,
                                            height: canvas.height,
                                            style: canvas.style.cssText,
                                            zIndex: getComputedStyle(canvas).zIndex
                                        });
                                    });
                                    
                                    // Check Fabric.js canvas state
                                    console.log('Fabric canvas state:', {
                                        width: this.canvas.width,
                                        height: this.canvas.height,
                                        backgroundColor: this.canvas.backgroundColor,
                                        objectsCount: this.canvas.getObjects().length,
                                        viewportTransform: this.canvas.viewportTransform
                                    });
                                    
                                    // Force a complete re-render with different methods
                                    console.log('Attempting multiple render methods...');
                                    this.canvas.requestRenderAll();
                                    this.canvas.renderAll();
                                    this.canvas.calcOffset();
                                    
                                    // Try to trigger a repaint
                                    setTimeout(() => {
                                        this.canvas.clear();
                                        this.canvas.add(objects[0]);
                                        this.canvas.renderAll();
                                        console.log('Attempted object re-add and render');
                                    }, 200);
                                }
                            }, 100);
                            
                            console.log('Image loaded to canvas successfully');
                            
                            // Clean up blob URL if created
                            if (processedImageUrl !== imageUrl) {
                                setTimeout(() => {
                                    URL.revokeObjectURL(processedImageUrl);
                                }, 1000);
                            }
                            
                            // Save initial state with image loaded
                            setTimeout(() => {
                                this.saveCanvasState();
                            }, 200);
                            
                        } catch (fabricError) {
                            console.error('Error creating Fabric image:', fabricError);
                        }
                    };
                    
                    testImg.onerror = (error) => {
                        console.error('Failed to load image:', error);
                        
                        // Clean up blob URL if created
                        if (processedImageUrl !== imageUrl) {
                            URL.revokeObjectURL(processedImageUrl);
                        }
                    };
                    
                    testImg.src = processedImageUrl;
                    
                } catch (error) {
                    console.error('Error processing image:', error);
                }
            }
            
            loadRecentImage(imageUrl) {
                this.loadImageToCanvas(imageUrl);
                this.expandStep('step3');
            }
            
            // Session-based user image management with size limits
            loadUserImages() {
                try {
                    const stored = localStorage.getItem('userImages');
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.warn('Failed to load user images from storage:', error);
                    // Clear corrupted data
                    localStorage.removeItem('userImages');
                    return [];
                }
            }
            
            // Check storage size and clean up if needed
            checkStorageSize() {
                try {
                    // Estimate current storage usage
                    let totalSize = 0;
                    for (let key in localStorage) {
                        if (localStorage.hasOwnProperty(key)) {
                            totalSize += localStorage[key].length;
                        }
                    }
                    
                    // If approaching 5MB limit (browsers typically allow 5-10MB)
                    const maxSize = 4 * 1024 * 1024; // 4MB limit to be safe
                    if (totalSize > maxSize) {
                        console.log('Storage approaching limit, cleaning up...');
                        this.cleanupOldImages();
                    }
                    
                    return totalSize;
                } catch (error) {
                    console.warn('Failed to check storage size:', error);
                    return 0;
                }
            }
            
            // Clean up old images to free space
            cleanupOldImages() {
                try {
                    // Sort by timestamp and keep only the 5 most recent
                    this.userImages.sort((a, b) => b.timestamp - a.timestamp);
                    this.userImages = this.userImages.slice(0, 5);
                    this.saveUserImages();
                    console.log('Cleaned up old images, kept 5 most recent');
                } catch (error) {
                    console.warn('Failed to cleanup images:', error);
                    // If cleanup fails, clear all images
                    this.userImages = [];
                    localStorage.removeItem('userImages');
                }
            }
            
            // Compress image data to reduce storage size
            compressImageData(imageData, maxWidth = 800, quality = 0.7) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Calculate new dimensions
                        let { width, height } = img;
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Draw and compress
                        ctx.drawImage(img, 0, 0, width, height);
                        const compressedData = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedData);
                    };
                    img.src = imageData;
                });
            }
            
            saveUserImages() {
                try {
                    const dataString = JSON.stringify(this.userImages);
                    
                    // Check if the data is too large
                    if (dataString.length > 3 * 1024 * 1024) { // 3MB limit for user images
                        console.warn('User images data too large, cleaning up...');
                        this.cleanupOldImages();
                        return;
                    }
                    
                    localStorage.setItem('userImages', dataString);
                } catch (error) {
                    if (error.name === 'QuotaExceededError') {
                        console.warn('Storage quota exceeded, cleaning up...');
                        this.cleanupOldImages();
                        
                        // Try saving again with cleaned data
                        try {
                            localStorage.setItem('userImages', JSON.stringify(this.userImages));
                        } catch (secondError) {
                            console.error('Failed to save even after cleanup, clearing all images');
                            this.userImages = [];
                            localStorage.removeItem('userImages');
                            this.showCustomAlert(
                                'Storage is full. All saved images have been cleared to make space. Please upload smaller images or use fewer images.',
                                'warning',
                                'Storage Full'
                            );
                        }
                    } else {
                        console.error('Failed to save user images:', error);
                    }
                }
            }
            
            async addUserImage(imageData, type = 'upload') {
                try {
                    // Compress the image to save space
                    let compressedData = imageData;
                    if (type === 'upload') {
                        console.log('Compressing uploaded image...');
                        compressedData = await this.compressImageData(imageData, 800, 0.8);
                        console.log('Image compressed successfully');
                    }
                    
                    const imageObject = {
                        id: Date.now() + Math.random(),
                        data: compressedData,
                        type: type, // 'upload' or 'generated'
                        timestamp: Date.now()
                    };
                    
                    // Check storage before adding
                    this.checkStorageSize();
                    
                    this.userImages.unshift(imageObject);
                    
                    // Limit to 8 images (reduced from 10 to save space)
                    if (this.userImages.length > 8) {
                        this.userImages = this.userImages.slice(0, 8);
                    }
                    
                    this.saveUserImages();
                    this.refreshUserImagesDisplay();
                    this.updateStorageInfo();
                    
                    // Show success message for uploads
                    if (type === 'upload') {
                        this.showCustomAlert('Image uploaded and optimized successfully!', 'success', 'Upload Complete');
                    }
                    
                } catch (error) {
                    console.error('Failed to add user image:', error);
                    this.showCustomAlert(
                        'Failed to save image. The image might be too large. Please try a smaller image.',
                        'error',
                        'Upload Failed'
                    );
                }
            }
            
            removeUserImage(imageId) {
                this.userImages = this.userImages.filter(img => img.id !== imageId);
                this.saveUserImages();
                this.refreshUserImagesDisplay();
                this.updateStorageInfo();
            }
            
            clearAllImages() {
                const confirmed = confirm('Are you sure you want to clear all saved images? This cannot be undone.');
                if (confirmed) {
                    this.userImages = [];
                    localStorage.removeItem('userImages');
                    this.refreshUserImagesDisplay();
                    this.updateStorageInfo();
                    this.showCustomAlert('All saved images have been cleared.', 'info', 'Images Cleared');
                }
            }
            
            updateStorageInfo() {
                try {
                    const storageData = localStorage.getItem('userImages');
                    const sizeInBytes = storageData ? storageData.length : 0;
                    const sizeInKB = Math.round(sizeInBytes / 1024);
                    const sizeInMB = (sizeInBytes / (1024 * 1024)).toFixed(1);
                    
                    const storageElement = document.getElementById('storageUsage');
                    if (storageElement) {
                        if (sizeInKB > 1024) {
                            storageElement.textContent = `Storage: ${sizeInMB} MB`;
                        } else {
                            storageElement.textContent = `Storage: ${sizeInKB} KB`;
                        }
                        
                        // Color code based on usage
                        if (sizeInBytes > 3 * 1024 * 1024) { // > 3MB
                            storageElement.style.color = '#ff4444';
                        } else if (sizeInBytes > 1.5 * 1024 * 1024) { // > 1.5MB
                            storageElement.style.color = '#ffaa00';
                        } else {
                            storageElement.style.color = '#888';
                        }
                    }
                } catch (error) {
                    console.warn('Failed to update storage info:', error);
                }
            }
            
            refreshUserImagesDisplay() {
                const grid = document.getElementById('userImagesGrid');
                
                if (this.userImages.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-gallery">
                            <i class="fas fa-images" style="font-size: 3rem; color: rgba(77, 162, 255, 0.3);"></i>
                            <p style="color: rgba(255,255,255,0.6); margin-top: 10px;">No images yet. Upload or generate some images first!</p>
                        </div>
                    `;
                } else {
                    grid.innerHTML = '';
                    this.userImages.forEach(image => {
                        const item = document.createElement('div');
                        item.className = 'recent-item';
                        item.innerHTML = `
                            <img src="${image.data}" alt="User image">
                            <button class="remove-image" onclick="event.stopPropagation(); memeGenerator.removeUserImage('${image.id}')" title="Remove image">
                                <i class="fas fa-times"></i>
                            </button>
                        `;
                        
                        // Add click event listener to show preview modal
                        item.addEventListener('click', (e) => {
                            // Prevent event if clicking on remove button
                            if (e.target.closest('.remove-image')) {
                                return;
                            }
                            this.selectUserImage(image.id);
                        });
                        
                        grid.appendChild(item);
                    });
                }
                
                // Update proceed button text and functionality
                const proceedBtn = document.getElementById('proceedToEdit');
                if (proceedBtn) {
                    const hasImages = this.userImages.length > 0;
                    proceedBtn.disabled = !hasImages;
                    if (hasImages) {
                        proceedBtn.innerHTML = '<i class="fas fa-eye"></i> Preview Images';
                        proceedBtn.onclick = () => {
                            if (this.userImages.length === 1) {
                                // If only one image, show it directly
                                this.showImagePreview(this.userImages[0]);
                            } else {
                                // If multiple images, show instruction
                                this.showCustomAlert('Click on any image above to preview and edit it.', 'info', 'Multiple Images');
                            }
                        };
                    } else {
                        proceedBtn.innerHTML = '<i class="fas fa-edit"></i> Edit Selected';
                        proceedBtn.onclick = () => this.proceedToEdit();
                    }
                }
            }
            
            selectUserImage(imageId) {
                // Ensure we have valid image data
                const image = this.userImages.find(img => img.id == imageId);
                if (!image) {
                    console.error('Image not found:', imageId);
                    return;
                }
                
                // Show image preview modal instead of just selecting
                this.showImagePreview(image);
            }
            
            showImagePreview(image) {
                // Create modal overlay if it doesn't exist
                let modal = document.getElementById('imagePreviewModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'imagePreviewModal';
                    modal.className = 'modal-overlay';
                    modal.innerHTML = `
                        <div class="modal-content image-preview-modal">
                            <button class="modal-close" id="previewModalClose">&times;</button>
                            <div class="modal-header">
                                <h2><i class="fas fa-image"></i> Image Preview</h2>
                            </div>
                            <div class="preview-content">
                                <div class="preview-image-container">
                                    <img id="previewImage" src="" alt="Image preview">
                                </div>
                                <div class="preview-info">
                                    <p id="previewType"></p>
                                    <p id="previewDate"></p>
                                </div>
                            </div>
                            <div class="preview-actions">
                                <button class="btn-small btn-secondary-small" id="previewBackBtn">
                                    <i class="fas fa-arrow-left"></i> Back
                                </button>
                                <button class="btn-small" id="previewEditBtn">
                                    <i class="fas fa-edit"></i> Edit This Image
                                </button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    
                    // Add event listeners after creating the modal
                    modal.addEventListener('click', (e) => {
                        // Close modal if clicking on overlay (not on modal content)
                        if (e.target === modal) {
                            this.closeImagePreview();
                        }
                    });
                    
                    document.getElementById('previewModalClose').addEventListener('click', () => {
                        this.closeImagePreview();
                    });
                    
                    document.getElementById('previewBackBtn').addEventListener('click', () => {
                        this.closeImagePreview();
                    });
                    
                    document.getElementById('previewEditBtn').addEventListener('click', () => {
                        this.editSelectedImage();
                    });
                }
                
                // Update modal content
                document.getElementById('previewImage').src = image.data;
                document.getElementById('previewType').textContent = `Type: ${image.type === 'generated' ? 'AI Generated' : 'Uploaded'}`;
                document.getElementById('previewDate').textContent = `Created: ${new Date(image.timestamp).toLocaleString()}`;
                
                // Store the selected image for editing
                this.selectedUserImage = image.id;
                
                // Show modal
                modal.classList.add('show');
                
                // Add keyboard listener for Escape key
                this.handleModalKeydown = (e) => {
                    if (e.key === 'Escape') {
                        this.closeImagePreview();
                    }
                };
                document.addEventListener('keydown', this.handleModalKeydown);
            }
            
            closeImagePreview() {
                const modal = document.getElementById('imagePreviewModal');
                if (modal) {
                    modal.classList.remove('show');
                }
                
                // Remove keyboard listener
                if (this.handleModalKeydown) {
                    document.removeEventListener('keydown', this.handleModalKeydown);
                    this.handleModalKeydown = null;
                }
            }
            
            editSelectedImage() {
                if (!this.selectedUserImage) {
                    this.showCustomAlert('No image selected!', 'warning', 'No Selection');
                    return;
                }
                
                const image = this.userImages.find(img => img.id === this.selectedUserImage);
                
                if (!image) {
                    this.showCustomAlert('Selected image not found.', 'error', 'Image Not Found');
                    return;
                }
                
                // Close the preview modal
                this.closeImagePreview();
                
                // Show the editor step first
                this.expandStep('step3');
                
                // Add a small delay to ensure the step is expanded and canvas is ready
                setTimeout(() => {
                    this.loadImageToCanvas(image.data);
                }, 100);
            }
             
             // Social sharing functionality
             openShareModal() {
                 const canvas = this.canvas;
                 if (canvas.isEmpty()) {
                     this.showCustomAlert('Please create a meme first before sharing!', 'info', 'Nothing to Share');
                     return;
                 }
                 
                 try {
                     // Convert canvas to data URL for preview and sharing
                     const dataURL = canvas.toDataURL({
                         format: 'png',
                         quality: 0.9,
                         multiplier: 1
                     });
                     
                     // Set the preview image
                     const previewImg = document.getElementById('sharePreviewImage');
                     if (previewImg) {
                         previewImg.src = dataURL;
                     }
                     
                     // Store the image data for sharing globally
                     window.currentShareImage = dataURL;
                     
                     // Show the modal
                     const modal = document.getElementById('shareModal');
                     if (modal) {
                         modal.classList.add('show');
                         console.log('Share modal opened with image data');
                     } else {
                         console.error('Share modal not found');
                     }
                 } catch (error) {
                     console.error('Error creating share preview:', error);
                     this.showCustomAlert('Failed to prepare meme for sharing. Please try again.', 'error', 'Share Error');
                 }
             }
            
            expandStep(stepId) {
                // Just expand the target step (allow multiple steps open)
                const step = document.getElementById(stepId);
                if (step) {
                    step.classList.add('active');
                    step.classList.remove('collapsed');
                    step.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            
            initializeStepStates() {
                // Ensure proper initial state for all steps
                document.querySelectorAll('.step-container').forEach(step => {
                    const stepHeader = step.querySelector('.step-header');
                    if (stepHeader) {
                        // Clear any inline styles that might be causing issues
                        stepHeader.style.background = '';
                        stepHeader.style.color = '';
                    }
                    
                    // Set proper collapsed state for inactive steps
                    if (!step.classList.contains('active')) {
                        step.classList.add('collapsed');
                    }
                });
            }
            
            setMode(mode) {
                this.currentMode = mode;
                
                // Update tool button states
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                if (mode === 'text') {
                    document.getElementById('addTextBtn').classList.add('active');
                    document.getElementById('shapeTools').style.display = 'none';
                    this.addText();
                } else if (mode === 'shape') {
                    document.getElementById('addShapeBtn').classList.add('active');
                    document.getElementById('shapeTools').style.display = 'grid';
                }
            }
            
            addText() {
                const textContent = document.getElementById('textInput').value || 'Your text here';
                const fontSize = parseInt(document.getElementById('fontSize').value);
                const fontFamily = document.getElementById('fontFamily').value;
                const textColor = document.getElementById('textColor').value;
                const strokeColor = document.getElementById('strokeColor').value;
                const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
                
                const text = new fabric.Text(textContent, {
                    left: 300,
                    top: 100,
                    fontSize: fontSize,
                    fontFamily: fontFamily,
                    fill: textColor,
                    stroke: strokeColor,
                    strokeWidth: strokeWidth,
                    textAlign: 'center',
                    fontWeight: 'bold',
                    hasControls: true,
                    hasBorders: true
                });
                
                this.canvas.add(text);
                this.canvas.setActiveObject(text);
                this.canvas.renderAll();
            }
            
            addShape(shapeType) {
                let shape;
                const fillColor = document.getElementById('fillColor').value;
                const borderColor = document.getElementById('borderColor').value;
                const borderWidth = parseInt(document.getElementById('borderWidth').value);
                
                const commonProps = {
                    left: 300,
                    top: 200,
                    fill: fillColor,
                    stroke: borderColor,
                    strokeWidth: borderWidth,
                    hasControls: true,
                    hasBorders: true
                };
                
                switch (shapeType) {
                    case 'rectangle':
                        shape = new fabric.Rect({
                            width: 150,
                            height: 100,
                            ...commonProps
                        });
                        break;
                    case 'circle':
                        shape = new fabric.Circle({
                            radius: 75,
                            ...commonProps
                        });
                        break;
                    case 'triangle':
                        shape = new fabric.Triangle({
                            width: 150,
                            height: 130,
                            ...commonProps
                        });
                        break;
                    case 'star':
                        const points = this.createStarPoints(5, 75, 35);
                        shape = new fabric.Polygon(points, {
                            ...commonProps
                        });
                        break;
                }
                
                if (shape) {
                    this.canvas.add(shape);
                    this.canvas.setActiveObject(shape);
                    this.canvas.renderAll();
                }
                
                // Update shape button states
                document.querySelectorAll('.shape-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-shape="${shapeType}"]`).classList.add('active');
            }
            
            createStarPoints(numPoints, outerRadius, innerRadius) {
                const points = [];
                const angleStep = Math.PI / numPoints;
                
                for (let i = 0; i < numPoints * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = i * angleStep - Math.PI / 2;
                    points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                
                return points;
            }
            
            onObjectSelected(e) {
                // Handle different Fabric.js event structures
                let target = null;
                
                if (e && e.target) {
                    target = e.target;
                } else if (e && e.selected && e.selected.length > 0) {
                    target = e.selected[0];
                } else if (e && typeof e === 'object' && e.type) {
                    // Sometimes the event IS the target object
                    target = e;
                }
                
                if (!target) {
                    console.warn('onObjectSelected: No valid target found', e);
                    return;
                }
                
                this.activeObject = target;
                this.updateControlsForObject(target);
                this.updateCopyPasteButtons();
            }
            
            onSelectionCleared() {
                this.activeObject = null;
                this.updateCopyPasteButtons();
            }
            
            updateControlsForObject(obj) {
                // Check if object exists and has the necessary properties
                if (!obj) {
                    return;
                }
                
                // Handle different object types
                if (obj.type === 'text' || obj.type === 'textbox') {
                    document.getElementById('textInput').value = obj.text || '';
                    document.getElementById('fontFamily').value = obj.fontFamily || 'Arial';
                    document.getElementById('fontSize').value = obj.fontSize || 20;
                    document.getElementById('textColor').value = this.rgbToHex(obj.fill) || '#000000';
                    document.getElementById('strokeColor').value = this.rgbToHex(obj.stroke) || '#000000';
                    document.getElementById('strokeWidth').value = obj.strokeWidth || 0;
                    
                    this.updateSliderValues();
                } else if (obj.type === 'image') {
                    // Handle image objects - no specific controls needed for basic images
                    console.log('Image object selected:', obj);
                } else if (obj.type === 'rect' || obj.type === 'circle' || obj.type === 'triangle') {
                    // Handle shape objects
                    console.log('Shape object selected:', obj.type);
                } else {
                    // Handle unknown object types
                    console.log('Unknown object type selected:', obj.type || 'undefined type');
                }
                
                // Update opacity
                document.getElementById('opacity').value = (obj.opacity || 1) * 100;
                document.getElementById('opacityValue').textContent = Math.round((obj.opacity || 1) * 100) + '%';
                
                // Update colors for shapes (convert RGB to hex)
                if (obj.type !== 'text') {
                    document.getElementById('fillColor').value = this.rgbToHex(obj.fill) || '#4DA2FF';
                    document.getElementById('borderColor').value = this.rgbToHex(obj.stroke) || '#ffffff';
                    document.getElementById('borderWidth').value = obj.strokeWidth || 0;
                    document.getElementById('borderWidthValue').textContent = (obj.strokeWidth || 0) + 'px';
                }
            }
            
            updateText() {
                const activeObject = this.canvas.getActiveObject();
                if (activeObject && activeObject.type === 'text') {
                    activeObject.set('text', document.getElementById('textInput').value);
                    this.canvas.renderAll();
                }
            }
            
            updateTextStyle() {
                const activeObject = this.canvas.getActiveObject();
                if (activeObject && activeObject.type === 'text') {
                    activeObject.set({
                        fontFamily: document.getElementById('fontFamily').value,
                        fill: document.getElementById('textColor').value,
                        stroke: document.getElementById('strokeColor').value
                    });
                    this.canvas.renderAll();
                }
            }
            
            updateFontSize() {
                const size = document.getElementById('fontSize').value;
                document.getElementById('fontSizeValue').textContent = size + 'px';
                
                const activeObject = this.canvas.getActiveObject();
                if (activeObject && activeObject.type === 'text') {
                    activeObject.set('fontSize', parseInt(size));
                    this.canvas.renderAll();
                }
            }
            
            updateStrokeWidth() {
                const width = document.getElementById('strokeWidth').value;
                document.getElementById('strokeWidthValue').textContent = width + 'px';
                
                const activeObject = this.canvas.getActiveObject();
                if (activeObject && activeObject.type === 'text') {
                    activeObject.set('strokeWidth', parseInt(width));
                    this.canvas.renderAll();
                }
            }
            
            updateOpacity() {
                const opacity = document.getElementById('opacity').value / 100;
                document.getElementById('opacityValue').textContent = Math.round(opacity * 100) + '%';
                
                const activeObject = this.canvas.getActiveObject();
                if (activeObject) {
                    activeObject.set('opacity', opacity);
                    this.canvas.renderAll();
                }
            }
            
            updateFillColor() {
                const color = document.getElementById('fillColor').value;
                const activeObject = this.canvas.getActiveObject();
                if (activeObject && activeObject.type !== 'text') {
                    activeObject.set('fill', color);
                    this.canvas.renderAll();
                }
            }
            
            updateBorderColor() {
                const color = document.getElementById('borderColor').value;
                const activeObject = this.canvas.getActiveObject();
                if (activeObject) {
                    activeObject.set('stroke', color);
                    this.canvas.renderAll();
                }
            }
            
            updateBorderWidth() {
                const width = document.getElementById('borderWidth').value;
                document.getElementById('borderWidthValue').textContent = width + 'px';
                
                const activeObject = this.canvas.getActiveObject();
                if (activeObject) {
                    activeObject.set('strokeWidth', parseInt(width));
                    this.canvas.renderAll();
                }
            }
            
            updateSliderValues() {
                document.getElementById('fontSizeValue').textContent = document.getElementById('fontSize').value + 'px';
                document.getElementById('strokeWidthValue').textContent = document.getElementById('strokeWidth').value + 'px';
                document.getElementById('opacityValue').textContent = document.getElementById('opacity').value + '%';
                document.getElementById('borderWidthValue').textContent = document.getElementById('borderWidth').value + 'px';
            }
            
            bringForward() {
                const activeObject = this.canvas.getActiveObject();
                if (activeObject) {
                    this.canvas.bringForward(activeObject);
                    this.canvas.renderAll();
                }
            }
            
            sendBackward() {
                const activeObject = this.canvas.getActiveObject();
                if (activeObject) {
                    this.canvas.sendBackwards(activeObject);
                    this.canvas.renderAll();
                }
            }
            
            deleteSelected() {
                const activeObject = this.canvas.getActiveObject();
                if (activeObject) {
                    this.canvas.remove(activeObject);
                    this.canvas.renderAll();
                }
            }
            
            // Copy/Paste functionality
            updateCopyPasteButtons() {
                const copyBtn = document.getElementById('copyBtn');
                const pasteBtn = document.getElementById('pasteBtn');
                
                // Enable copy button if there's a selected object (but not the background image)
                const hasSelection = this.activeObject && this.activeObject.type !== 'image';
                copyBtn.disabled = !hasSelection;
                copyBtn.style.opacity = hasSelection ? '1' : '0.5';
                
                // Enable paste button if there's something in clipboard
                const hasClipboard = this.clipboard !== null;
                pasteBtn.disabled = !hasClipboard;
                pasteBtn.style.opacity = hasClipboard ? '1' : '0.5';
            }
            
            copySelected() {
                const activeObject = this.canvas.getActiveObject();
                if (activeObject && activeObject.type !== 'image') {
                    // Clone the object and store it in clipboard
                    activeObject.clone((clonedObj) => {
                        this.clipboard = clonedObj;
                        this.pasteCount = 0; // Reset paste counter for new copy
                        this.updateCopyPasteButtons();
                        
                        // Visual feedback
                        const copyBtn = document.getElementById('copyBtn');
                        const originalText = copyBtn.innerHTML;
                        copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                        setTimeout(() => {
                            copyBtn.innerHTML = originalText;
                        }, 1000);
                    });
                }
            }
            
            pasteElement() {
                if (this.clipboard) {
                    // Clone the clipboard object and add it to canvas
                    this.clipboard.clone((clonedObj) => {
                        this.pasteCount++;
                        
                        // Smart offset based on paste count
                        const offset = this.pasteCount * 25;
                        clonedObj.set({
                            left: clonedObj.left + offset,
                            top: clonedObj.top + offset,
                            evented: true,
                        });
                        
                        // Make sure the pasted object stays within canvas bounds
                        if (clonedObj.left + clonedObj.width > 600) {
                            clonedObj.left = 20;
                        }
                        if (clonedObj.top + clonedObj.height > 600) {
                            clonedObj.top = 20;
                        }
                        
                        this.canvas.add(clonedObj);
                        this.canvas.setActiveObject(clonedObj);
                        this.canvas.renderAll();
                        
                        // Visual feedback
                        const pasteBtn = document.getElementById('pasteBtn');
                        const originalText = pasteBtn.innerHTML;
                        pasteBtn.innerHTML = '<i class="fas fa-check"></i> Pasted!';
                        setTimeout(() => {
                            pasteBtn.innerHTML = originalText;
                        }, 1000);
                    });
                }
            }
            
            handleKeyboardShortcuts(e) {
                // Only handle shortcuts when not typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Ctrl+C - Copy
                if (e.ctrlKey && e.key === 'c') {
                    e.preventDefault();
                    this.copySelected();
                }
                
                // Ctrl+V - Paste
                if (e.ctrlKey && e.key === 'v') {
                    e.preventDefault();
                    this.pasteElement();
                }
                
                // Delete key - Delete selected
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    this.deleteSelected();
                }
                
                // Escape - Clear selection
                if (e.key === 'Escape') {
                    this.canvas.discardActiveObject();
                    this.canvas.renderAll();
                }
            }
            
            saveCanvasState() {
                // Don't save state if we're currently loading from history
                if (this.isLoadingFromHistory) {
                    return;
                }
                
                const state = JSON.stringify(this.canvas.toJSON());
                this.historyIndex++;
                
                // Remove any future states if we're not at the end
                if (this.historyIndex < this.history.length) {
                    this.history.length = this.historyIndex;
                }
                
                this.history.push(state);
                
                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                // Update button states
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadCanvasState(this.history[this.historyIndex]);
                    this.updateUndoRedoButtons();
                }
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadCanvasState(this.history[this.historyIndex]);
                    this.updateUndoRedoButtons();
                }
            }
            
            loadCanvasState(state) {
                // Set flag to prevent saving state during load
                this.isLoadingFromHistory = true;
                
                this.canvas.loadFromJSON(state, () => {
                    this.canvas.renderAll();
                    // Reset flag after loading is complete
                    this.isLoadingFromHistory = false;
                });
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                // Update undo button
                if (undoBtn) {
                    undoBtn.disabled = this.historyIndex <= 0;
                    undoBtn.style.opacity = this.historyIndex <= 0 ? '0.5' : '1';
                }
                
                // Update redo button
                if (redoBtn) {
                    redoBtn.disabled = this.historyIndex >= this.history.length - 1;
                    redoBtn.style.opacity = this.historyIndex >= this.history.length - 1 ? '0.5' : '1';
                }
            }
            
            async clearCanvas() {
                const confirmed = await this.showCustomConfirm('Are you sure you want to clear the canvas?', 'Clear Canvas');
                if (confirmed) {
                    this.canvas.clear();
                    this.canvas.backgroundColor = '#ffffff';
                    this.canvas.renderAll();
                    
                    // Reset selection state when clearing canvas
                    this.selectedUserImage = null;
                    this.refreshUserImagesDisplay();
                    
                    // Save state after clearing
                    this.saveCanvasState();
                }
            }
            
            exportMeme() {
                const link = document.createElement('a');
                link.download = 'aqua-meme.png';
                link.href = this.canvas.toDataURL('image/png');
                link.click();
            }
            
            async saveMeme() {
                // Ask for X username
                const xUsername = prompt('Enter your X (Twitter) username (optional, without @):');
                
                const canvas = this.canvas.getElement();
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
                
                const formData = new FormData();
                formData.append('canvas', blob, 'meme.png');
                formData.append('tags', '$AQUA,meme,crypto');
                
                // Add X username if provided
                if (xUsername && xUsername.trim()) {
                    formData.append('xUsername', xUsername.trim().replace('@', ''));
                }
                
                try {
                    const response = await fetch('/api/memes/create', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        this.showCustomAlert('Meme saved successfully to the gallery! üéâ', 'success', 'Meme Saved');
                        this.refreshUserImagesDisplay(); // Refresh user images
                    } else {
                        this.showCustomAlert('Failed to save meme: ' + result.error, 'error', 'Save Failed');
                    }
                } catch (error) {
                    console.error('Error saving meme:', error);
                    this.showCustomAlert('Failed to save meme. Please try again.', 'error', 'Save Failed');
                }
            }

            async saveAndShare() {
                const canvas = this.canvas;
                if (canvas.isEmpty()) {
                    this.showCustomAlert('Please create a meme first before sharing!', 'info', 'Nothing to Share');
                    return;
                }
                
                try {
                    // First, save the meme to the gallery
                    const canvasElement = canvas.getElement();
                    const blob = await new Promise(resolve => {
                        canvasElement.toBlob(resolve, 'image/png');
                    });
                    
                    const formData = new FormData();
                    formData.append('canvas', blob, 'meme.png');
                    formData.append('tags', '$AQUA,meme,crypto');
                    
                    const response = await fetch('/api/memes/create', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        // Show success message
                        this.showCustomAlert('Meme saved successfully to the gallery! üéâ', 'success', 'Meme Saved');
                        this.refreshUserImagesDisplay(); // Refresh user images
                        
                        // Then open the share modal
                        this.openShareModal();
                    } else {
                        this.showCustomAlert('Failed to save meme: ' + result.error, 'error', 'Save Failed');
                    }
                } catch (error) {
                    console.error('Error saving and sharing meme:', error);
                    this.showCustomAlert('Failed to save meme. Please try again.', 'error', 'Save Failed');
                }
            }
            
            shareToTwitter() {
                const text = encodeURIComponent('Check out my $AQUA meme! üíéüåä #AQUA #MemeGenerator #SUI');
                const url = encodeURIComponent(window.location.origin);
                window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
            }
            
            shareToReddit() {
                const title = encodeURIComponent('My $AQUA Meme Creation!');
                const url = encodeURIComponent(window.location.origin + '/meme-generator');
                window.open(`https://reddit.com/submit?title=${title}&url=${url}`, '_blank');
            }
            
            setupScrollAnimations() {
                const observerOptions = {
                    threshold: 0.1,
                    rootMargin: '0px 0px -50px 0px'
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('in-view');
                        }
                    });
                }, observerOptions);

                document.querySelectorAll('.scroll-animate').forEach(el => {
                    observer.observe(el);
                });
            }
            
            proceedToEdit() {
                // Fallback method for backward compatibility
                if (this.userImages.length > 0) {
                    this.showImagePreview(this.userImages[0]);
                } else {
                    this.showCustomAlert('No images available. Please upload or generate an image first.', 'info', 'No Images');
                }
            }
            
            // Social sharing functionality
            shareToSocial(platform) {
                // Implementation for social sharing
            }
            
            // Custom Alert and Confirm Functions
            showCustomAlert(message, type = 'info', title = '') {
                return new Promise((resolve) => {
                    // Remove existing alert modal if any
                    const existingModal = document.getElementById('customAlertModal');
                    if (existingModal) {
                        existingModal.remove();
                    }
                    
                    // Create modal
                    const modal = document.createElement('div');
                    modal.id = 'customAlertModal';
                    modal.className = 'modal-overlay';
                    
                    // Determine icon based on type
                    let icon = '';
                    switch(type) {
                        case 'success':
                            icon = '<i class="fas fa-check-circle alert-icon success"></i>';
                            break;
                        case 'error':
                            icon = '<i class="fas fa-exclamation-triangle alert-icon error"></i>';
                            break;
                        case 'warning':
                            icon = '<i class="fas fa-exclamation-circle alert-icon warning"></i>';
                            break;
                        default:
                            icon = '<i class="fas fa-info-circle alert-icon info"></i>';
                    }
                    
                    modal.innerHTML = `
                        <div class="modal-content custom-alert-modal">
                            <button class="modal-close" id="alertModalClose">&times;</button>
                            ${title ? `<div class="modal-header"><h2>${title}</h2></div>` : ''}
                            <div class="alert-content">
                                ${icon}
                                <div class="alert-message">${message}</div>
                                <div class="alert-actions">
                                    <button class="btn btn-confirm" id="alertOkBtn">OK</button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Event listeners
                    const closeModal = () => {
                        modal.classList.remove('show');
                        setTimeout(() => {
                            if (modal.parentNode) {
                                modal.parentNode.removeChild(modal);
                            }
                        }, 300);
                        resolve();
                    };
                    
                    document.getElementById('alertModalClose').addEventListener('click', closeModal);
                    document.getElementById('alertOkBtn').addEventListener('click', closeModal);
                    
                    // Click outside to close
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            closeModal();
                        }
                    });
                    
                    // Keyboard support
                    const handleKeydown = (e) => {
                        if (e.key === 'Escape' || e.key === 'Enter') {
                            closeModal();
                            document.removeEventListener('keydown', handleKeydown);
                        }
                    };
                    document.addEventListener('keydown', handleKeydown);
                    
                    // Show modal
                    modal.classList.add('show');
                });
            }
            
            showCustomConfirm(message, title = 'Confirm Action') {
                return new Promise((resolve) => {
                    // Remove existing confirm modal if any
                    const existingModal = document.getElementById('customConfirmModal');
                    if (existingModal) {
                        existingModal.remove();
                    }
                    
                    // Create modal
                    const modal = document.createElement('div');
                    modal.id = 'customConfirmModal';
                    modal.className = 'modal-overlay';
                    
                    modal.innerHTML = `
                        <div class="modal-content custom-alert-modal">
                            <button class="modal-close" id="confirmModalClose">&times;</button>
                            <div class="modal-header"><h2>${title}</h2></div>
                            <div class="alert-content">
                                <i class="fas fa-question-circle alert-icon warning"></i>
                                <div class="alert-message">${message}</div>
                                <div class="alert-actions">
                                    <button class="btn btn-confirm" id="confirmYesBtn">Yes</button>
                                    <button class="btn btn-cancel" id="confirmNoBtn">Cancel</button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Event listeners
                    const closeModal = (result) => {
                        modal.classList.remove('show');
                        setTimeout(() => {
                            if (modal.parentNode) {
                                modal.parentNode.removeChild(modal);
                            }
                        }, 300);
                        resolve(result);
                    };
                    
                    document.getElementById('confirmModalClose').addEventListener('click', () => closeModal(false));
                    document.getElementById('confirmYesBtn').addEventListener('click', () => closeModal(true));
                    document.getElementById('confirmNoBtn').addEventListener('click', () => closeModal(false));
                    
                    // Click outside to close
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            closeModal(false);
                        }
                    });
                    
                    // Keyboard support
                    const handleKeydown = (e) => {
                        if (e.key === 'Escape') {
                            closeModal(false);
                            document.removeEventListener('keydown', handleKeydown);
                        } else if (e.key === 'Enter') {
                            closeModal(true);
                            document.removeEventListener('keydown', handleKeydown);
                        }
                    };
                    document.addEventListener('keydown', handleKeydown);
                    
                    // Show modal
                    modal.classList.add('show');
                });
            }
            
            // Helper function to convert RGB color to hex format
            rgbToHex(color) {
                if (!color) return '#000000';
                
                // If already hex, return as is
                if (color.startsWith('#')) {
                    return color;
                }
                
                // Convert rgb(r,g,b) to hex
                if (color.startsWith('rgb')) {
                    const matches = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (matches) {
                        const r = parseInt(matches[1]);
                        const g = parseInt(matches[2]);
                        const b = parseInt(matches[3]);
                        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                    }
                }
                
                // If unknown format, return default
                return '#000000';
            }
        }
        
        // Make functions globally accessible
        // Global functions for social sharing modal
        function closeShareModal() {
            document.getElementById('shareModal').classList.remove('show');
        }
        
        // Convert data URL to File object for sharing
        function dataURLtoFile(dataurl, filename) {
            const arr = dataurl.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new File([u8arr], filename, {type: mime});
        }
        
        // Native Web Share API (works on mobile and some desktop browsers)
        async function shareWithNativeAPI(platform) {
            if (!navigator.share) {
                return false; // Not supported
            }
            
            try {
                const message = document.getElementById('shareMessage').value || 'Check out this awesome meme I made! üî• #AQUA #MemeGenerator #SUI';
                const imageFile = dataURLtoFile(window.currentShareImage, 'aqua-meme.png');
                
                const shareData = {
                    title: '$AQUA Meme',
                    text: message,
                    files: [imageFile]
                };
                
                // Check if files are supported
                if (navigator.canShare && navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                    return true;
                } else {
                    // Try without files
                    await navigator.share({
                        title: '$AQUA Meme',
                        text: message,
                        url: window.location.origin
                    });
                    return true;
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('Native share failed:', error);
                }
                return false;
            }
        }
        
        // Universal share function (uses native Web Share API)
        async function shareUniversal() {
            const message = document.getElementById('shareMessage').value || 'Check out this awesome meme I made! üî• #AQUA #MemeGenerator #SUI';
            
            if (!navigator.share) {
                // Fallback for browsers without Web Share API
                window.memeGenerator.showCustomAlert(
                    'üåê Universal sharing not supported on this browser.\n\nPlease use one of the platform-specific buttons below, or try on a mobile device for better sharing options.',
                    'info',
                    'Share Not Available'
                );
                return;
            }
            
            try {
                const imageFile = dataURLtoFile(window.currentShareImage, 'aqua-meme.png');
                
                const shareData = {
                    title: '$AQUA Meme Generator',
                    text: message,
                    files: [imageFile]
                };
                
                // Check if files are supported
                if (navigator.canShare && navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                    
                    // Close the modal on successful share
                    closeShareModal();
                    
                    // Show success message
                    window.memeGenerator.showCustomAlert(
                        'üéâ Meme shared successfully!\n\nYour meme and message were shared together. Thanks for spreading the $AQUA love! üåäüíé',
                        'success',
                        'Shared Successfully'
                    );
                } else {
                    // Try without files (text + URL only)
                    await navigator.share({
                        title: '$AQUA Meme Generator',
                        text: message,
                        url: window.location.origin
                    });
                    
                    // Download image separately
                    const link = document.createElement('a');
                    link.download = 'aqua-meme.png';
                    link.href = window.currentShareImage;
                    link.click();
                    
                    closeShareModal();
                    
                    window.memeGenerator.showCustomAlert(
                        'üì± Shared with text and link!\n\nüì∏ Your meme image was also downloaded. Upload it to your shared post for the complete experience!',
                        'info',
                        'Partial Share Complete'
                    );
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    // User cancelled - do nothing
                    return;
                }
                
                console.warn('Universal share failed:', error);
                window.memeGenerator.showCustomAlert(
                    '‚ùå Sharing failed.\n\nPlease try one of the platform-specific buttons below.',
                    'error',
                    'Share Failed'
                );
            }
        }
        
        function shareToTwitter() {
            const message = document.getElementById('shareMessage').value || 'Check out this awesome meme I made! üî• #AQUA #MemeGenerator #SUI';
            
            // Try native share first (works on mobile)
            shareWithNativeAPI('twitter').then(success => {
                if (!success) {
                    // Fallback: Use Twitter Web Intent with image download
                    if (window.currentShareImage) {
                        // Create a download link for the image
                        const link = document.createElement('a');
                        link.download = 'aqua-meme.png';
                        link.href = window.currentShareImage;
                        link.click();
                        
                        // Open Twitter with text after a short delay
                        setTimeout(() => {
                            const text = encodeURIComponent(message + ' üåäüíé');
                            const url = `https://twitter.com/intent/tweet?text=${text}`;
                            window.open(url, '_blank');
                            
                            // Show improved instruction
                            window.memeGenerator.showCustomAlert(
                                'üì∏ Image downloaded!\n\n1. Your tweet window is now open\n2. Click the photo button in the tweet composer\n3. Select the downloaded "aqua-meme.png" file\n4. Your text is already added - just tweet! üöÄ',
                                'info',
                                'Share on X (Twitter)'
                            );
                        }, 500);
                    }
                }
            });
        }
        
        function shareToReddit() {
            const message = document.getElementById('shareMessage').value || 'Check out this awesome $AQUA meme I made! üî•';
            
            // Try native share first
            shareWithNativeAPI('reddit').then(success => {
                if (!success) {
                    // Fallback: Reddit doesn't support direct image posting via URL
                    // But we can make it easier by opening the submit page for image posts
                    if (window.currentShareImage) {
                        // Download the image
                        const link = document.createElement('a');
                        link.download = 'aqua-meme.png';
                        link.href = window.currentShareImage;
                        link.click();
                        
                        // Open Reddit submit page for images
                        setTimeout(() => {
                            const url = 'https://www.reddit.com/submit?type=IMAGE';
                            window.open(url, '_blank');
                            
                            window.memeGenerator.showCustomAlert(
                                'üì∏ Image downloaded!\n\n1. Reddit\'s image post page is now open\n2. Click "Choose File" and select "aqua-meme.png"\n3. Add your title: "' + message + '"\n4. Choose a subreddit (try r/memes or r/cryptocurrency)\n5. Post your meme! üöÄ',
                                'info',
                                'Share on Reddit'
                            );
                        }, 500);
                    }
                }
            });
        }
        
        function shareToFacebook() {
            const message = document.getElementById('shareMessage').value || 'Check out this awesome meme I made! üî• #AQUA #MemeGenerator';
            
            // Try native share first
            shareWithNativeAPI('facebook').then(success => {
                if (!success) {
                    // Facebook has strict policies, but we can make it easier
                    if (window.currentShareImage) {
                        // Download the image
                        const link = document.createElement('a');
                        link.download = 'aqua-meme.png';
                        link.href = window.currentShareImage;
                        link.click();
                        
                        // Open Facebook
                        setTimeout(() => {
                            const url = 'https://www.facebook.com/';
                            window.open(url, '_blank');
                            
                            window.memeGenerator.showCustomAlert(
                                'üì∏ Image downloaded!\n\n1. Facebook is now open\n2. Click "What\'s on your mind?" to create a post\n3. Click the photo/video button\n4. Upload "aqua-meme.png"\n5. Add your message: "' + message + '"\n6. Share your meme! üöÄ',
                                'info',
                                'Share on Facebook'
                            );
                        }, 500);
                    }
                }
            });
        }
        
        function shareToInstagram() {
            const message = document.getElementById('shareMessage').value || 'Check out this awesome meme I made! üî• #AQUA #MemeGenerator #SUI';
            
            // Try native share first (works great on mobile)
            shareWithNativeAPI('instagram').then(success => {
                if (!success) {
                    if (window.currentShareImage) {
                        // Download the image
                        const link = document.createElement('a');
                        link.download = 'aqua-meme.png';
                        link.href = window.currentShareImage;
                        link.click();
                        
                        // Detect if mobile
                        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        
                        setTimeout(() => {
                            if (isMobile) {
                                // Try to open Instagram app
                                window.location.href = 'instagram://camera';
                                
                                setTimeout(() => {
                                    window.memeGenerator.showCustomAlert(
                                        'üì∏ Image downloaded!\n\n1. Instagram should open (or open it manually)\n2. Tap + to create new post\n3. Select "aqua-meme.png" from your photos\n4. Add caption: "' + message + '"\n5. Share your meme! üì∏‚ú®',
                                        'info',
                                        'Share on Instagram'
                                    );
                                }, 1000);
                            } else {
                                // Desktop - open Instagram web
                                window.open('https://www.instagram.com/', '_blank');
                                
                                window.memeGenerator.showCustomAlert(
                                    'üì∏ Image downloaded!\n\nüí° Instagram works best on mobile!\n\n1. Instagram web is now open\n2. Click + to create new post\n3. Upload "aqua-meme.png"\n4. Add caption: "' + message + '"\n5. Share your meme! üì∏',
                                    'info',
                                    'Share on Instagram'
                                );
                            }
                        }, 500);
                    }
                }
            });
        }
        
        function shareToTikTok() {
            const message = document.getElementById('shareMessage').value || 'Check out this awesome meme I made! üî• #AQUA #MemeGenerator #SUI';
            
            // Try native share first
            shareWithNativeAPI('tiktok').then(success => {
                if (!success) {
                    if (window.currentShareImage) {
                        // Download the image
                        const link = document.createElement('a');
                        link.download = 'aqua-meme.png';
                        link.href = window.currentShareImage;
                        link.click();
                        
                        // Detect if mobile
                        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        
                        setTimeout(() => {
                            if (isMobile) {
                                // Try to open TikTok app
                                window.location.href = 'tiktok://';
                                
                                setTimeout(() => {
                                    window.memeGenerator.showCustomAlert(
                                        'üì∏ Image downloaded!\n\n1. TikTok should open (or open it manually)\n2. Tap + to create new video\n3. Use "aqua-meme.png" as your content\n4. Add effects, music, and text\n5. Caption: "' + message + '"\n6. Post your meme video! üéµ‚ú®',
                                        'info',
                                        'Share on TikTok'
                                    );
                                }, 1000);
                            } else {
                                // Desktop - TikTok web is limited
                                window.open('https://www.tiktok.com/', '_blank');
                                
                                window.memeGenerator.showCustomAlert(
                                    'üì∏ Image downloaded!\n\nüí° TikTok works best on mobile!\n\nFor best results:\n1. Send "aqua-meme.png" to your phone\n2. Open TikTok app\n3. Create video using your meme\n4. Add: "' + message + '"\n5. Post your creation! üéµ',
                                    'info',
                                    'Share on TikTok'
                                );
                            }
                        }, 500);
                    }
                }
            });
        }
        
        // Initialize advanced meme generator when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.memeGenerator = new AdvancedMemeGenerator();
            
            // Add social sharing event listeners
            document.querySelectorAll('.social-platform').forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const platform = this.getAttribute('data-platform');
                    
                    switch(platform) {
                        case 'universal':
                            shareUniversal();
                            break;
                        case 'twitter':
                            shareToTwitter();
                            break;
                        case 'reddit':
                            shareToReddit();
                            break;
                        case 'facebook':
                            shareToFacebook();
                            break;
                        case 'instagram':
                            shareToInstagram();
                            break;
                        case 'tiktok':
                            shareToTikTok();
                            break;
                    }
                });
            });
            
            // Add modal close event listeners
            const closeBtn = document.querySelector('[data-action="close-modal"]');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeShareModal);
            }
            
            // Add escape key to close modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('shareModal');
                    if (modal && modal.classList.contains('show')) {
                        closeShareModal();
                    }
                }
            });
            
            // Close modal when clicking outside
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('modal-overlay')) {
                    closeShareModal();
                }
            });
        });
    </script>
</body>
</html> 